{
  "meta.json": "{\n  \"rank\": 28,\n  \"title\": \"Faking the TCP handshake\",\n  \"url\": \"http://lgms.nl/blog-2\",\n  \"hn_url\": \"https://news.ycombinator.com/item?id=10654285\",\n  \"points\": 104,\n  \"author\": \"citizenk\",\n  \"comment_count\": 30\n}",
  "article.txt": "Luc Gommans - Faking the TCP handshake\nLuc Gommans\n/\nblog\nFaking the TCP handshake\nWritten on 2015-11-30\nUpdate:\nThis article has been superseded by a new post which hopefully explains it more clearly:\nSpoofing TCP connections without sequence number prediction\nTo the best of our knowledge, this attack is a new finding. Asking around, people assume the TCP handshake verifies the IP addresses on both sides. This attack shows that this is not actually true.\nIn a collaborative project for the Fontys University of Applied Sciences, Raoul Houkes and I researched different ways to attack TCP, either at implementation or protocol level. What we found was a protocol-level attack, affecting all correct implementations.\nThe TCP handshake works like this, with A being the client that is connecting to B:\nA:\nHi B, I'm A, send number 5.\nB:\nHi A, I'm B, 5, send number 3.\nA:\nHi B, I'm A, 3, send number 6. I'd like example.net.\nB:\nHi A, I'm B, 6, send number 4. Here comes the data: ...\nAfter this, A can send data to B and B can send data to A. For each byte of data they send to each other, their numbers increase. This is to keep track of whether all data has been received by the other party, to ensure reliable transmission.\nWhen this was designed in 1981, security was no priority. The ARPANET efficiently fit in a single list and they needed a protocol to send data without worrying about retransmitting on errors, checksumming to check for errors, keeping packets in order, etc. TCP solved all of this.\nThese numeric fields, called the 'sequence' and 'acknowledgement' numbers, are currently used for security as well as reliable transmission. This causes two problems:\nThe fields are not particularly large (32 bits).\nDue to their dual purpose, incorrect numbers have to be discarded without corrupting the connection. In other words, you can send incorrect acknowledgement numbers and subsequent packets with a correct acknowledgement number will be accepted just fine.\nWe combined these two properties into our attack, which would look roughly like this, where A is sending packets to B:\nA:\nHi B, I'm C, send number 5.\nB:\nHi C, I'm B, 5, send number 3.\nA:\nHi B, I'm C, 1, send number 6. I'd like example.net.\nB:\nHi C, I'm B, that's incorrect. Close the connection please.\nA:\nHi B, I'm C, 2, send number 6. I'd like example.net.\nB:\nHi C, I'm B, that's incorrect. Close the connection please.\nA:\nHi B, I'm C, 3, send number 6. I'd like example.net.\nB:\nHi C, I'm B, 6, send number 4. Here comes the data: ...\nIn this example, host A never receives any of B's messages and B does not know that it's responding to a fake IP address. Host A is faking its IP address into C.\nOne prerequisite for the attack is that the real C will not actually send &quot;Huh what is going on&quot;-packets (or RST packets), but that is easy: either take a non-existent C (e.g. 0.0.0.0) or take advantage of firewalls (clients are typically behind a stateful firewall, or NAT, or both).\nThe time B will wait for C (or any other client) to confirm the connection is limited. On a Linux 4.2 kernel I tried this and it turned out to be 20 seconds. After these 20 seconds you need to start over (send another SYN), but this does not make any difference since the chosen numbers are completely random.\nThe cost of the attack? On average it takes 120GB of network traffic (counting 60 bytes for the ethernet header, IP header and TCP header combined) to create a spoofed connection. You could get unlucky and need 200GB of traffic, but it's equally likely to get lucky and only need 72GB.\nA quick search reveals many VPS systems with 1gbps bandwidth for very little money. If you take full advantage of the available bandwidth, the attack takes 17 minutes and 11 seconds on average.\nUsually you will want to inject a payload, for example to send a command. This command needs to be appended to the existing data, making the attack larger. For example sending &quot;GET / HTTP/1.0\\n\\n&quot; takes on average 152GB or 20 minutes. This will show up in the access logs as a perfectly normal connection though.\nOther examples of this attack include getting around black- or whitelists, for example on management interfaces of certain systems. This was really popular in the 90s, but many are still around and plenty new applications still work this way.\nProof of concept\nWhat is a research project without a proof of concept? Here are screenshots from Wireshark, a packet dump, and the code that was used.\nI filtered out the relevant packets, as captured by the target: 192.168.36.17. The first packet is the initial hello, sent by 192.168.36.11, spoofing 192.168.36.18. Our target responds to the fake IP address, and what happens next is that the tool starts guessing the right acknowledgement number. Note the time jump from 0.x seconds to 8.x seconds, here I filtered out a number of attempts. At some point, the number goes from 2^32 (4.x billion) to zero, this is because Wireshark gives us relative numbers. It also means we've found the right number. Relative acknowledgement number 1 is the one we need to have! After receiving that one, the SSH server responds with its banner, as an SSH server always does upon receiving a valid TCP connection.\nHere is the conversation in some more detail:\nThe random number picked by the server is 0x0006943f (or 431167).\nAt some point, our script comes across 0x00069440 (or 431168), which is the right number because we need to send what we received plus one.\nIn response to that, SSH gives us the banner that is always sent at the beginning of a valid connection.\nThe original packet dump is only 15 seconds long because I captured 15 seconds around the event before rotating logs. Sounds like nothing, but it's 5 544 384 (5.5 million) packets and almost half a gigabyte. If you want to see this, you could just run the attack and see for yourself.\nThe packet dump that is visible above can be downloaded here:\nspoofed-tcp-connection.pcap\nAnd finally, the code that was used to perform the attack can be downloaded here:\nattack-tcp.py\nAs a true proof of concept, it's specifically written for this purpose and the code is not made to be maintainable ;)\nConclusion\nThe attack is difficult to mitigate due to the nature of the TCP protocol. Only wildly incorrect guesses at the acknowledgement number could be rejected as invalid and could be used as a reason to close the connection, but even then that leaves a large enough window to exploit.\nTo authenticate both sides of a connection, additional security such as TLS needs to be used. Even if the certificate is not authenticated, any encrypted TLS session will do because there is additional data that needs to be received by the client. Spoofing becomes infeasible.\nLesson of the day: never use IP address-based authentication, don't trust IP address whitelists, and use security protocols when you need security (or non-repudiation).",
  "comments.json": "[\n  {\n    \"id\": 10662834,\n    \"author\": \"arpa\",\n    \"text\": \"well AFAIR TCP RST attack works exactly like that...https://en.wikipedia.org/wiki/TCP_reset_attackSo I doubt this is a new finding.\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T13:42:10.000Z\",\n    \"children\": []\n  },\n  {\n    \"id\": 10662838,\n    \"author\": \"tptacek\",\n    \"text\": \"I'm not sure this is new. The technique of suppressing responses from the spoof source is as old as TCP sequencing, and was a prerequisite for Laurent Joncheray's \\\"Simple Active Attack Against TCP\\\" that introduced session hijacking.Also see:http://phrack.org/issues/64/13.html\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T13:42:57.000Z\",\n    \"children\": [\n      {\n        \"id\": 10662867,\n        \"author\": \"wtbob\",\n        \"text\": \"Perhaps what's new is that it is so easily exploitable?I remember when 32 bits seemed huuuge, and now \\u2026 not so much.\",\n        \"points\": null,\n        \"created_at\": \"2015-12-02T13:49:08.000Z\",\n        \"children\": [\n          {\n            \"id\": 10662888,\n            \"author\": \"armitron\",\n            \"text\": \"No it's not, the author \\\"failed\\\" to mention that the vast majority of networks drop spoofed packets. It may be exploitable inside a target network, locally, but one usually has a lot better options if he has a foothold there, than bruteforcing sequence numbers with gigabytes of traffic for a single connection.It's dumb is what it is.\",\n            \"points\": null,\n            \"created_at\": \"2015-12-02T13:52:58.000Z\",\n            \"children\": [\n              {\n                \"id\": 10662994,\n                \"author\": \"laumars\",\n                \"text\": \"> It's dumb is what it is.Steady on there. The author has clearly done a lot of work on this and while your points are valid, that this method of attack isn't new nor practical, he has still learned a very genuine potential vector for attack. Thus it deserves a mature discussion since there will certainly be others who might learn from the author's research.I'm all for constructive criticisms, but calling his article \\\"dumb\\\" is just unnecessary language. It doesn't contribute anything and yet could discourage authors from publishing future work.\",\n                \"points\": null,\n                \"created_at\": \"2015-12-02T14:13:46.000Z\",\n                \"children\": []\n              },\n              {\n                \"id\": 10663083,\n                \"author\": \"jacquesm\",\n                \"text\": \"Anti-spoof measures are really only effective close to the edge, further in packets are routed with abandon because of overhead and difficulty in verifying the origin.\",\n                \"points\": null,\n                \"created_at\": \"2015-12-02T14:28:41.000Z\",\n                \"children\": []\n              },\n              {\n                \"id\": 10669306,\n                \"author\": \"fulafel\",\n                \"text\": \"Counting on the attacker's own network to have egress filtering stopping his attacks, isn't that a bit like discounting spam because most networks filter outbound SMTP?If your defenses are predicated on the assumption that you aren't going to encounter bad stuff due to filtering at the source, you are in for a bad time.\",\n                \"points\": null,\n                \"created_at\": \"2015-12-03T13:00:26.000Z\",\n                \"children\": []\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"id\": 10662841,\n    \"author\": \"armitron\",\n    \"text\": \"This attack has been around forever and ever, I don't see anything new. In fact, it's the opposite, his method is \\nnaive (dumb bruteforcing). Moreover, a lot (the vast majority) of networks these days drop spoofed packets (egress).The phrack article describes a lot more sophisticated attack.Mitnick used it to hack Shimomura.http://wiki.cas.mcmaster.ca/index.php/The_Mitnick_attackMore recent but still 9 years old:\\nhttp://phrack.com/issues/64/13.html#article\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T13:43:15.000Z\",\n    \"children\": [\n      {\n        \"id\": 10662894,\n        \"author\": \"tptacek\",\n        \"text\": \"I don't think probing the whole ISN space is new, but that's not how the tool Mitnick was given worked. At the time of the Mitnick attack, TCP ISNs were trivially predictable; you could connect to a host, note its ISN, and then know within a very tight range what the next ISN on the next connection --- from any host --- would be.\",\n        \"points\": null,\n        \"created_at\": \"2015-12-02T13:53:51.000Z\",\n        \"children\": [\n          {\n            \"id\": 10662898,\n            \"author\": \"armitron\",\n            \"text\": \"The sequence number prediction specifics are different, but the attack is the same, blind TCP spoofing.\",\n            \"points\": null,\n            \"created_at\": \"2015-12-02T13:54:45.000Z\",\n            \"children\": [\n              {\n                \"id\": 10662907,\n                \"author\": \"tptacek\",\n                \"text\": \"I think it depends on how you read the article. The most charitable reading is that the authors couldn't find a source for probing the whole ISN space, and believe that variant of the attack is novel. I think you have to be a bit uncharitable to assume they're claiming the whole concept of blind TCP spoofing.\",\n                \"points\": null,\n                \"created_at\": \"2015-12-02T13:56:17.000Z\",\n                \"children\": [\n                  {\n                    \"id\": 10662936,\n                    \"author\": \"armitron\",\n                    \"text\": \"I would cut them a lot more slack if they mentioned that their method doesn't work in the vast majority of networks today (assuming one wants to cross networks with it), due to egress filtering. If one is already present locally, and can send spoofed packets, there are far better attacks to try than sending tens to hundreds of gigabytes of data for a single spoofed connection (that will be immediately terminated).Their method doesn't even attempt to keep the connection going.Anyone with network experience would see the bruteforcing method as elementary and common knowledge really, it's nothing new.In short, amateur hour.\",\n                    \"points\": null,\n                    \"created_at\": \"2015-12-02T14:02:18.000Z\",\n                    \"children\": [\n                      {\n                        \"id\": 10662942,\n                        \"author\": \"tptacek\",\n                        \"text\": \"Since TCP spoofing is essentially an academic concept at this point --- even if you could do it in milliseconds, it wouldn't be very useful --- I'm not sure the practical baggage or refinements you're talking about are that important.Also, I think RPF filtering is a little less common than you're implying that it is.\",\n                        \"points\": null,\n                        \"created_at\": \"2015-12-02T14:03:54.000Z\",\n                        \"children\": [\n                          {\n                            \"id\": 10663216,\n                            \"author\": \"fulafel\",\n                            \"text\": \"Why not useful? In my experience setups involving IP ACLs for TCP services are pretty common in the wild. As well as risk-assesments talking about the relative rarity of on-path attackers, predicated on TCP security against off-path attackers.\",\n                            \"points\": null,\n                            \"created_at\": \"2015-12-02T14:50:23.000Z\",\n                            \"children\": [\n                              {\n                                \"id\": 10664082,\n                                \"author\": \"AnthonyMouse\",\n                                \"text\": \"Risk assessments making bad assumptions is not a new thing.People are always advocating egress filtering because \\\"if only everybody would do it ...\\\", but it's a classic tragedy of the commons. Egress filtering doesn't meaningfully help the network doing it and it may cause ugly problems with asymmetric routes and the like, so the number of networks that don't do it is large enough to be meaningful. And if you get close enough to the core of the internet it's basically impossible anyway because there is no practical way to keep track of which address ranges a particular interface should legitimately be sending traffic from when the list encompasses half the address ranges on the internet and can change at any time.The upshot being it's not at all difficult for an attacker to get hold of a connection that doesn't do egress filtering, and that isn't ever going to change.\",\n                                \"points\": null,\n                                \"created_at\": \"2015-12-02T16:55:18.000Z\",\n                                \"children\": []\n                              }\n                            ]\n                          }\n                        ]\n                      }\n                    ]\n                  }\n                ]\n              },\n              {\n                \"id\": 10665693,\n                \"author\": \"zurn\",\n                \"text\": \"It's different: The old was attacking weak randomness, this is showing easy brute forcing.\",\n                \"points\": null,\n                \"created_at\": \"2015-12-02T20:49:59.000Z\",\n                \"children\": []\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"id\": 10663245,\n        \"author\": \"SFjulie1\",\n        \"text\": \"And it was easy because the PRNG had a small volume in the space phasehttp://lcamtuf.coredump.cx/newtcp/What I don't understand is why the use of Taken's series are still not a standard for the analysis of the randomness...It resulted in this CVE http://www.cert.org/historical/advisories/CA-2001-09.cfmAnd almost all the industry either switching to linux or as the licence authorized it they could have used BSD TCP stack since then, I guess.Here is an horrible implementation of Taken's visualization.https://gist.github.com/jul/0f16782ed01f18c2c72a\",\n        \"points\": null,\n        \"created_at\": \"2015-12-02T14:54:33.000Z\",\n        \"children\": []\n      }\n    ]\n  },\n  {\n    \"id\": 10662854,\n    \"author\": \"ikeboy\",\n    \"text\": \"http://lcamtuf.coredump.cx/oldtcp/tcpseq.html> However, guessing the right ISN from the entire 32-bit space (4,294,967,296 possibilities) is not feasible due to the excessive amount of bandwidth and time required. That is why a good TCP sequence number generator implementation currently provides enough security to protect against spoofing attacks, at least for the present time and in typical conditions. But increasing bandwidth and processor speed will eventually make brute force guessing of 32-bit ISNs feasible for the average attacker.See also \\nhttp://www.jakoblell.com/blog/2013/08/13/quick-blind-tcp-con...\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T13:46:31.000Z\",\n    \"children\": []\n  },\n  {\n    \"id\": 10662941,\n    \"author\": \"peterwwillis\",\n    \"text\": \"Everything old is new again. Here's how Nmap helps you identify hosts that are easy to attack so you don't have to brute force them:  TCP Sequence Prediction\\n  \\n  Systems with poor TCP initial sequence number generation are vulnerable to \\n  blind TCP spoofing attacks. In other words, you can make a full connection to \\n  those systems and send (but not receive) data while spoofing a different\\n  IP address. The target's logs will show the spoofed IP, and you can take \\n  advantage of any trust relationship between them. This attack was all the\\n  rage in the mid-nineties when people commonly used rlogin to allow logins \\n  to their account without any password from trusted IP addresses. \\n  Kevin Mitnick is alleged to have used this attack to break into Tsutomu Shimomura's \\n  computers in December 1994.\\n  \\n  The good news is that hardly anyone uses rlogin anymore, and many operating \\n  systems have been fixed to use unpredictable initial sequence numbers \\n  as proposed by RFC 1948. For these reasons, this line is only printed in \\n  verbose mode. Sadly, many vendors still ship vulnerable operating systems \\n  and devices. Even the fixed ones often vary in implementation, which \\n  leaves them valuable for OS detection purposes.\\n  [..]\\n  Further details about sequence tests are provided in the section called \\n  \\u201cTCP ISN greatest common divisor (GCD)\\u201d [1].\\n\\nhttps://nmap.org/book/osdetect-usage.html [1] https://nmap.org/book/osdetect-methods.html#osdetect-gcdA fun look at sequence number PNRGs of various (old) OSes: http://lcamtuf.coredump.cx/newtcp/\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T14:03:45.000Z\",\n    \"children\": []\n  },\n  {\n    \"id\": 10663099,\n    \"author\": \"fabioyy\",\n    \"text\": \"who remember Mitnick and rsh?\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T14:32:04.000Z\",\n    \"children\": []\n  },\n  {\n    \"id\": 10663564,\n    \"author\": \"abpavel\",\n    \"text\": \"This is not an attack vector, because:\\n1. TCP SNs are usually moving. By default they don't need to, as that's part of the core ideology (thanks Postel!) but today they are usually moving.\\n2. Since connection has to be live before hand, servers request will be received by the client who will close the connection.\\n3. SNs provide only basic level of security, and this research proves, yet again for 35th straight year, that it's pretty good for what it is. 100+gigs of data just to be able to send a single packet over cleartext TCP is not bad at all. Universities and DCs may have this BW, but it isn't widespread.\\n4. This is just a bruteforce.\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T15:40:31.000Z\",\n    \"children\": []\n  },\n  {\n    \"id\": 10664014,\n    \"author\": \"biot\",\n    \"text\": \"To add to the older evidence: http://www.bsdcan.org/2006/papers/ImprovingTCPIP.pdf\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T16:47:23.000Z\",\n    \"children\": []\n  },\n  {\n    \"id\": 10664668,\n    \"author\": \"barhun\",\n    \"text\": \"i've been aware of this attack for about 10 years, how can it be a new finding? the following article was written in 1997.http://www.citi.umich.edu/u/provos/papers/secnet-spoof.txt\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T18:10:45.000Z\",\n    \"children\": [\n      {\n        \"id\": 10664688,\n        \"author\": \"barhun\",\n        \"text\": \"the boy is 21 years old, forget it.\",\n        \"points\": null,\n        \"created_at\": \"2015-12-02T18:14:16.000Z\",\n        \"children\": [\n          {\n            \"id\": 10668347,\n            \"author\": \"lgommans\",\n            \"text\": \"Then again, I did read (parts of) the RFC from '81, some paper (from Morris iirc) about predicting the ISN from '85, lots of research in the 90's and early 00's regarding predictions and preventing it... but nothing actually just guessed the number, and people seemed to agree that \\\"if the ISN is unpredictable then yeah it's secure right?\\\" That's why I considered this a new thing.\",\n            \"points\": null,\n            \"created_at\": \"2015-12-03T07:40:34.000Z\",\n            \"children\": []\n          }\n        ]\n      },\n      {\n        \"id\": 10668328,\n        \"author\": \"lucb1e\",\n        \"text\": \"That involves \\\"source routing\\\" though (from what I get, that means controlling the route a packet will take, at least partially). I only see one ACK being returned, not multiple, so apparently the attacker is able to receive the SYN+ACK here. This means it's a different attack.\",\n        \"points\": null,\n        \"created_at\": \"2015-12-03T07:37:25.000Z\",\n        \"children\": []\n      }\n    ]\n  },\n  {\n    \"id\": 10665276,\n    \"author\": \"Smushman\",\n    \"text\": \"Unfortunately for the author, this analysis is rooted in a faulty conclusion:\\\"Asking around, people assume the TCP handshake verifies the IP addresses on both sides.\\\"Not true - in firewall and security circles this was long ago observed and addressed in many different ways - it is now standard in at least the major Enterprise Firewall Vendors.Still though; the analysis is good, and clearly determined through work, observation, and sound logic. I would work alongside a person like this anytime.If the author can find a venue to assert his findings he/she should, but I wouldn't expend too much time on it.\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T19:38:52.000Z\",\n    \"children\": [\n      {\n        \"id\": 10668377,\n        \"author\": \"lgommans\",\n        \"text\": \"> Not true - in firewall and security circles this was long ago observed and addressed in many different ways - it is now standard in at least the major Enterprise Firewall Vendors.Hmm, what kind of measures are taken against this, then? Because aside from ingress filtering for RFC1918 addresses and the like, I don't see how you could prevent this attack effectively. You could make it more difficult by rejecting wildly incorrect acknowledgement numbers, but I don't see how to really prevent it.> Still though; the analysis is good, and clearly determined through work, observation, and sound logic. I would work alongside a person like this anytime.Thank you! :)\",\n        \"points\": null,\n        \"created_at\": \"2015-12-03T07:48:32.000Z\",\n        \"children\": [\n          {\n            \"id\": 10668784,\n            \"author\": \"Smushman\",\n            \"text\": \"I am most familiar with are in Checkpoint Firewall. They include several features that would limit this through session verification that tracks every packet, the sequence numbers associated (uses prediction), TCP flag states, etc.When the attacker submitted sequence numbers that were not correct for the connection, it would send a TCP reset to both the client and the server; forcing the attacker to begin the attack sequence again with the first SYN. If it recognized a replay (sequence numbers used twice) like would happen here too, it would also reset the session. There are others as well such as packet data enforcement (if the packet data portions did not match up to a valid session) and session proxying too.Lastly, it would lock out that attacker as a DDOS based on the traffic patterns (TCP sliding windows have been exceeded, or too much data in one direction and nothing returned).The idea during design was that there are insecurities the TCP protocol inherently permits (like this one), how can we limit those. The answer basically is that if a session displays 'errant but technically permitted by RFC' behaviors, the firewall should force a reset on the connection.If your conclusion at this point is can't this block valid traffic, the answer is yes it can, and these features are often turned off or limited for that reason.Be aware that I have not pieced this together completely - it would take more detailed research and time to provide valid evidence - this is just off the top of my head over few minutes.HTH...\",\n            \"points\": null,\n            \"created_at\": \"2015-12-03T10:01:03.000Z\",\n            \"children\": []\n          }\n        ]\n      }\n    ]\n  },\n  {\n    \"id\": 10666132,\n    \"author\": \"suprjami\",\n    \"text\": \"Regardless of how new/old this is, shouldn't TCP Timestamps provide some degree of protection against this too? If the spoofing host's TSval is less than the real host's TSval, the spoofed traffic will just be dropped as being \\\"from the past\\\". I'm not immediately sure if there's a limit to how much \\\"into the future\\\" the next TSval can be.\",\n    \"points\": null,\n    \"created_at\": \"2015-12-02T21:54:48.000Z\",\n    \"children\": []\n  }\n]"
}